<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Java中的String" /><meta property="og:locale" content="en_US" /><meta name="description" content="不可变类型 String是不可变类型（immutable），String.java源码中声明如下： 1 private final byte[] value; String通过字节数组来实现，且被声明为private final byte类型，表明对外的不可访问性（private），以及不可改变性（final）； 如果试图对其改变，会生成新的对象： 1 2 3 4 5 String s1 = &quot;abc&quot;; String s2 = s1; System.out.println(s1 == s2); s1 = &quot;def&quot;; System.out.println(s1 == s2); 输出结果为： 1 2 true false 原本s1和s2指向的是同一内存空间地址，所以先输出true，接着将”def”赋值给s1，由于String是不可变类型，不能够将原来地址中存放的内容改变成”def”，所以将创建新的”def”，并将它的地址赋值给s1，所以此时输出结果为false。 ==和equals 在java中等号==一般用于判断两者内存地址是否相同，而重载过的equals方法常用于判断内容是否相同，比如在String.java源码中，equals方法定义如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String aString = (String)anObject; if (coder() == aString.coder()) { return isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); } } return false; } 首先判断内存地址是否相等，如果内存地址相等，说明两者指向同一对象，那么存储的内容也必然是相同的；如果内存地址不相等，再判断待比较的对象是否是String类的实例，如果是，再判断编码方式是否相同（单字节编码或双字节编码），在编码方式相同的情况下，分别调用不同编码方式下的比较函数，比较它们的value值（上面所提到的value数组）是否相等。 字符串常量池 常量池是为了避免频繁的创建和销毁对象而影响系统性能，JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化：为字符串开辟一个字符串常量池，类似于缓存区；创建字符串常量时，首先检查字符串常量池是否存在该字符串，如果存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中： 1 2 3 String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; System.out.println(s1 == s2); 首先创建一个字符串”abc”，由于常量池中当前没有任何字符串，所以创建该字符串”abc”并将其加入字符串常量池中，然后返回其引用（地址），接着创建s2，首先在线程池中检查，发现有”abc”，所以直接返回其引用（地址），所以输出结果为true； 在如下的例子中，稍微做了一些改变： 1 2 3 String s1 = &quot;abc&quot;; String s2 = new String(&quot;abc&quot;); System.out.println(s1 == s2); 这段代码使用构造函数来构造一个字符串”abc”，此时输出结果为false，表明两者指向的地址不同，如果按照上面的思路，在构造s2时，首先检查常量池，发现有”abc”，那么应该直接返回它的地址，并得到true的结果，但并不是这样的；对于用String( )构造的字符串，它们不属于常量，而是变量，不能在程序编译的时候就确定地址，它们有自己的内存地址空间；也就是说在JVM机制中，常量和变量享有不同区域的内存空间，两者是不会重叠的； 再看如下代码段： 1 2 3 4 String s1 = &quot;abc&quot;; String s2 = new String(&quot;abc&quot;); s2 = s2.intern(); System.out.println(s1 == s2); 此时输出结果为true，加了一行代码，结果就变的不同；intern( )是扩充常量池的一个方法；当一个String实例调用intern()方法时，Java查找常量池中是否有相同的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加此字符串并返回它的引用； 所以在本段代码中，对s2调用intern方法时，检查到常量池中有”abc”，所以返回它的引用，所以s1和s2指向的是同一个来自于常量池中的”abc”，所以两者地址相同，结果为true，而原先s2指向的变量类型的”abc”被丢弃； 为了总结上述内容，再看如下代码段： 1 2 3 4 5 6 7 8 String s1 = new String(&quot;x&quot;); String s2 = s1; String s3 = &quot;x&quot;; s1 = s1.intern(); s2 = &quot;xxxx&quot;; System.out.println(s1 == s3); System.out.println(&quot;s1 : &quot; + s1); System.out.println(&quot;s2 : &quot; + s2); 输出结果为： 1 trues1 : xs2 : xxxx 第1行，使用String构造函数创建字符串”x”，同时在常量池中增加”x”，此时s1指向的是变量类型的”x”，而不是常量池中的”x”； 第2行，将s1赋值给s2，此时s2指向变量类型的”x”； 第3行，创建”x”，返回的是常量池中的”x”的地址； 第4行，将s1指向常量池中的”x”； 第5行，改变s2为”xxxx”，并将其添加到常量池中； 第6行，得到结果为true，因为都指向常量池中对象； 第7行，结果为x； 第8行，由于是不可变类型，所以输出xxxx； 常量的编译优化 看如下的代码： 1 String s1 = &quot;abc&quot;;String s2 = s1;System.out.println(s1 == s2);s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;System.out.println(s1 == s2); 结果为： 1 truetrue 在IDE中查看.class文件，其实是查看它反编译后的代码，查看上述代码反编译后的代码如下： 1 String s1 = &quot;abc&quot;;String s2 = s1;System.out.println(s1 == s1);s1 = &quot;abc&quot;;System.out.println(s1 == s2); 在s1的地方，本来写的是三个字符串相加，但经过反编译查看得到是最后的结果，也就是编译器做出了优化，在编译时就能确定”a” + “b” + “c”的结果为”abc”，所以不会分别将abc添加到常量池中，而是对它们的结果进行添加；进一步地，通过javap -c查看字节码，也未发现有abc单独出现的迹象： 1 0: ldc #2 // String abc 2: astore_1 3: aload_1 4: astore_2 5: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 8: aload_1 9: aload_2 10: if_acmpne 17 13: iconst_1 14: goto 18 17: iconst_0 18: invokevirtual #4 // Method java/io/PrintStream.println:(Z)V 21: ldc #2 // String abc 23: astore_1 在21行和0行，都只出现了完整的abc； 杂问题 问如下代码创建了几个对象： 1 String s1 = &quot;abc&quot;; 答：两个，一个在堆内存中（变量内存位置），一个在常量池中； 如下代码结果： 1 String s1 = &quot;ab&quot;;String s2 = &quot;abc&quot;;String s3 = s1 + &quot;c&quot;; System.out.println(s3 == s2); 答：false，常量和变量相加得到变量，所以s3指向的是变量的空间，s2指向的是常量池中地址，两者不可能相等； –end–" /><meta property="og:description" content="不可变类型 String是不可变类型（immutable），String.java源码中声明如下： 1 private final byte[] value; String通过字节数组来实现，且被声明为private final byte类型，表明对外的不可访问性（private），以及不可改变性（final）； 如果试图对其改变，会生成新的对象： 1 2 3 4 5 String s1 = &quot;abc&quot;; String s2 = s1; System.out.println(s1 == s2); s1 = &quot;def&quot;; System.out.println(s1 == s2); 输出结果为： 1 2 true false 原本s1和s2指向的是同一内存空间地址，所以先输出true，接着将”def”赋值给s1，由于String是不可变类型，不能够将原来地址中存放的内容改变成”def”，所以将创建新的”def”，并将它的地址赋值给s1，所以此时输出结果为false。 ==和equals 在java中等号==一般用于判断两者内存地址是否相同，而重载过的equals方法常用于判断内容是否相同，比如在String.java源码中，equals方法定义如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String aString = (String)anObject; if (coder() == aString.coder()) { return isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); } } return false; } 首先判断内存地址是否相等，如果内存地址相等，说明两者指向同一对象，那么存储的内容也必然是相同的；如果内存地址不相等，再判断待比较的对象是否是String类的实例，如果是，再判断编码方式是否相同（单字节编码或双字节编码），在编码方式相同的情况下，分别调用不同编码方式下的比较函数，比较它们的value值（上面所提到的value数组）是否相等。 字符串常量池 常量池是为了避免频繁的创建和销毁对象而影响系统性能，JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化：为字符串开辟一个字符串常量池，类似于缓存区；创建字符串常量时，首先检查字符串常量池是否存在该字符串，如果存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中： 1 2 3 String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; System.out.println(s1 == s2); 首先创建一个字符串”abc”，由于常量池中当前没有任何字符串，所以创建该字符串”abc”并将其加入字符串常量池中，然后返回其引用（地址），接着创建s2，首先在线程池中检查，发现有”abc”，所以直接返回其引用（地址），所以输出结果为true； 在如下的例子中，稍微做了一些改变： 1 2 3 String s1 = &quot;abc&quot;; String s2 = new String(&quot;abc&quot;); System.out.println(s1 == s2); 这段代码使用构造函数来构造一个字符串”abc”，此时输出结果为false，表明两者指向的地址不同，如果按照上面的思路，在构造s2时，首先检查常量池，发现有”abc”，那么应该直接返回它的地址，并得到true的结果，但并不是这样的；对于用String( )构造的字符串，它们不属于常量，而是变量，不能在程序编译的时候就确定地址，它们有自己的内存地址空间；也就是说在JVM机制中，常量和变量享有不同区域的内存空间，两者是不会重叠的； 再看如下代码段： 1 2 3 4 String s1 = &quot;abc&quot;; String s2 = new String(&quot;abc&quot;); s2 = s2.intern(); System.out.println(s1 == s2); 此时输出结果为true，加了一行代码，结果就变的不同；intern( )是扩充常量池的一个方法；当一个String实例调用intern()方法时，Java查找常量池中是否有相同的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加此字符串并返回它的引用； 所以在本段代码中，对s2调用intern方法时，检查到常量池中有”abc”，所以返回它的引用，所以s1和s2指向的是同一个来自于常量池中的”abc”，所以两者地址相同，结果为true，而原先s2指向的变量类型的”abc”被丢弃； 为了总结上述内容，再看如下代码段： 1 2 3 4 5 6 7 8 String s1 = new String(&quot;x&quot;); String s2 = s1; String s3 = &quot;x&quot;; s1 = s1.intern(); s2 = &quot;xxxx&quot;; System.out.println(s1 == s3); System.out.println(&quot;s1 : &quot; + s1); System.out.println(&quot;s2 : &quot; + s2); 输出结果为： 1 trues1 : xs2 : xxxx 第1行，使用String构造函数创建字符串”x”，同时在常量池中增加”x”，此时s1指向的是变量类型的”x”，而不是常量池中的”x”； 第2行，将s1赋值给s2，此时s2指向变量类型的”x”； 第3行，创建”x”，返回的是常量池中的”x”的地址； 第4行，将s1指向常量池中的”x”； 第5行，改变s2为”xxxx”，并将其添加到常量池中； 第6行，得到结果为true，因为都指向常量池中对象； 第7行，结果为x； 第8行，由于是不可变类型，所以输出xxxx； 常量的编译优化 看如下的代码： 1 String s1 = &quot;abc&quot;;String s2 = s1;System.out.println(s1 == s2);s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;System.out.println(s1 == s2); 结果为： 1 truetrue 在IDE中查看.class文件，其实是查看它反编译后的代码，查看上述代码反编译后的代码如下： 1 String s1 = &quot;abc&quot;;String s2 = s1;System.out.println(s1 == s1);s1 = &quot;abc&quot;;System.out.println(s1 == s2); 在s1的地方，本来写的是三个字符串相加，但经过反编译查看得到是最后的结果，也就是编译器做出了优化，在编译时就能确定”a” + “b” + “c”的结果为”abc”，所以不会分别将abc添加到常量池中，而是对它们的结果进行添加；进一步地，通过javap -c查看字节码，也未发现有abc单独出现的迹象： 1 0: ldc #2 // String abc 2: astore_1 3: aload_1 4: astore_2 5: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 8: aload_1 9: aload_2 10: if_acmpne 17 13: iconst_1 14: goto 18 17: iconst_0 18: invokevirtual #4 // Method java/io/PrintStream.println:(Z)V 21: ldc #2 // String abc 23: astore_1 在21行和0行，都只出现了完整的abc； 杂问题 问如下代码创建了几个对象： 1 String s1 = &quot;abc&quot;; 答：两个，一个在堆内存中（变量内存位置），一个在常量池中； 如下代码结果： 1 String s1 = &quot;ab&quot;;String s2 = &quot;abc&quot;;String s3 = s1 + &quot;c&quot;; System.out.println(s3 == s2); 答：false，常量和变量相加得到变量，所以s3指向的是变量的空间，s2指向的是常量池中地址，两者不可能相等； –end–" /><link rel="canonical" href="https://littlemoon-zh.github.io/posts/Java-string/" /><meta property="og:url" content="https://littlemoon-zh.github.io/posts/Java-string/" /><meta property="og:site_name" content="Littlemoon" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-04-08T07:50:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Java中的String" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"headline":"Java中的String","dateModified":"2021-06-08T09:22:26-04:00","datePublished":"2019-04-08T07:50:00-04:00","description":"不可变类型 String是不可变类型（immutable），String.java源码中声明如下： 1 private final byte[] value; String通过字节数组来实现，且被声明为private final byte类型，表明对外的不可访问性（private），以及不可改变性（final）； 如果试图对其改变，会生成新的对象： 1 2 3 4 5 String s1 = &quot;abc&quot;; String s2 = s1; System.out.println(s1 == s2); s1 = &quot;def&quot;; System.out.println(s1 == s2); 输出结果为： 1 2 true false 原本s1和s2指向的是同一内存空间地址，所以先输出true，接着将”def”赋值给s1，由于String是不可变类型，不能够将原来地址中存放的内容改变成”def”，所以将创建新的”def”，并将它的地址赋值给s1，所以此时输出结果为false。 ==和equals 在java中等号==一般用于判断两者内存地址是否相同，而重载过的equals方法常用于判断内容是否相同，比如在String.java源码中，equals方法定义如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String aString = (String)anObject; if (coder() == aString.coder()) { return isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); } } return false; } 首先判断内存地址是否相等，如果内存地址相等，说明两者指向同一对象，那么存储的内容也必然是相同的；如果内存地址不相等，再判断待比较的对象是否是String类的实例，如果是，再判断编码方式是否相同（单字节编码或双字节编码），在编码方式相同的情况下，分别调用不同编码方式下的比较函数，比较它们的value值（上面所提到的value数组）是否相等。 字符串常量池 常量池是为了避免频繁的创建和销毁对象而影响系统性能，JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化：为字符串开辟一个字符串常量池，类似于缓存区；创建字符串常量时，首先检查字符串常量池是否存在该字符串，如果存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中： 1 2 3 String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; System.out.println(s1 == s2); 首先创建一个字符串”abc”，由于常量池中当前没有任何字符串，所以创建该字符串”abc”并将其加入字符串常量池中，然后返回其引用（地址），接着创建s2，首先在线程池中检查，发现有”abc”，所以直接返回其引用（地址），所以输出结果为true； 在如下的例子中，稍微做了一些改变： 1 2 3 String s1 = &quot;abc&quot;; String s2 = new String(&quot;abc&quot;); System.out.println(s1 == s2); 这段代码使用构造函数来构造一个字符串”abc”，此时输出结果为false，表明两者指向的地址不同，如果按照上面的思路，在构造s2时，首先检查常量池，发现有”abc”，那么应该直接返回它的地址，并得到true的结果，但并不是这样的；对于用String( )构造的字符串，它们不属于常量，而是变量，不能在程序编译的时候就确定地址，它们有自己的内存地址空间；也就是说在JVM机制中，常量和变量享有不同区域的内存空间，两者是不会重叠的； 再看如下代码段： 1 2 3 4 String s1 = &quot;abc&quot;; String s2 = new String(&quot;abc&quot;); s2 = s2.intern(); System.out.println(s1 == s2); 此时输出结果为true，加了一行代码，结果就变的不同；intern( )是扩充常量池的一个方法；当一个String实例调用intern()方法时，Java查找常量池中是否有相同的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加此字符串并返回它的引用； 所以在本段代码中，对s2调用intern方法时，检查到常量池中有”abc”，所以返回它的引用，所以s1和s2指向的是同一个来自于常量池中的”abc”，所以两者地址相同，结果为true，而原先s2指向的变量类型的”abc”被丢弃； 为了总结上述内容，再看如下代码段： 1 2 3 4 5 6 7 8 String s1 = new String(&quot;x&quot;); String s2 = s1; String s3 = &quot;x&quot;; s1 = s1.intern(); s2 = &quot;xxxx&quot;; System.out.println(s1 == s3); System.out.println(&quot;s1 : &quot; + s1); System.out.println(&quot;s2 : &quot; + s2); 输出结果为： 1 trues1 : xs2 : xxxx 第1行，使用String构造函数创建字符串”x”，同时在常量池中增加”x”，此时s1指向的是变量类型的”x”，而不是常量池中的”x”； 第2行，将s1赋值给s2，此时s2指向变量类型的”x”； 第3行，创建”x”，返回的是常量池中的”x”的地址； 第4行，将s1指向常量池中的”x”； 第5行，改变s2为”xxxx”，并将其添加到常量池中； 第6行，得到结果为true，因为都指向常量池中对象； 第7行，结果为x； 第8行，由于是不可变类型，所以输出xxxx； 常量的编译优化 看如下的代码： 1 String s1 = &quot;abc&quot;;String s2 = s1;System.out.println(s1 == s2);s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;System.out.println(s1 == s2); 结果为： 1 truetrue 在IDE中查看.class文件，其实是查看它反编译后的代码，查看上述代码反编译后的代码如下： 1 String s1 = &quot;abc&quot;;String s2 = s1;System.out.println(s1 == s1);s1 = &quot;abc&quot;;System.out.println(s1 == s2); 在s1的地方，本来写的是三个字符串相加，但经过反编译查看得到是最后的结果，也就是编译器做出了优化，在编译时就能确定”a” + “b” + “c”的结果为”abc”，所以不会分别将abc添加到常量池中，而是对它们的结果进行添加；进一步地，通过javap -c查看字节码，也未发现有abc单独出现的迹象： 1 0: ldc #2 // String abc 2: astore_1 3: aload_1 4: astore_2 5: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 8: aload_1 9: aload_2 10: if_acmpne 17 13: iconst_1 14: goto 18 17: iconst_0 18: invokevirtual #4 // Method java/io/PrintStream.println:(Z)V 21: ldc #2 // String abc 23: astore_1 在21行和0行，都只出现了完整的abc； 杂问题 问如下代码创建了几个对象： 1 String s1 = &quot;abc&quot;; 答：两个，一个在堆内存中（变量内存位置），一个在常量池中； 如下代码结果： 1 String s1 = &quot;ab&quot;;String s2 = &quot;abc&quot;;String s3 = s1 + &quot;c&quot;; System.out.println(s3 == s2); 答：false，常量和变量相加得到变量，所以s3指向的是变量的空间，s2指向的是常量池中地址，两者不可能相等； –end–","url":"https://littlemoon-zh.github.io/posts/Java-string/","mainEntityOfPage":{"@type":"WebPage","@id":"https://littlemoon-zh.github.io/posts/Java-string/"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>Java中的String | Littlemoon</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Littlemoon"><meta name="application-name" content="Littlemoon"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://user-images.githubusercontent.com/85326814/120988886-8b970080-c7b1-11eb-94bf-e85764bd368c.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Littlemoon</a></div><div class="site-subtitle font-italic">Learn more, write more.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>POSTS</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUTME</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>TIMELINE</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/littlemoon-zh" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['yuhangxiaocs','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Java中的String</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Java中的String</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> littlemoon </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Apr 8, 2019, 7:50 AM -0400" prep="on" > Apr 8, 2019 <i class="unloaded">2019-04-08T07:50:00-04:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Jun 8, 2021, 9:22 PM +0800" prefix="Updated " > Jun 8 <i class="unloaded">2021-06-08T09:22:26-04:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1811 words">10 min</span></div></div><div class="post-content"><h2 id="不可变类型"><strong>不可变类型</strong></h2><p>String是不可变类型（immutable），String.java源码中声明如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">value</span><span class="o">;</span>
</pre></table></code></div></div><p>String通过字节数组来实现，且被声明为private final byte类型，表明对外的不可访问性（private），以及不可改变性（final）；</p><p>如果试图对其改变，会生成新的对象：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span>
<span class="n">s1</span> <span class="o">=</span> <span class="s">"def"</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span>
</pre></table></code></div></div><p>输出结果为：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kc">true</span>
<span class="kc">false</span>
</pre></table></code></div></div><p>原本s1和s2指向的是同一内存空间地址，所以先输出true，接着将”def”赋值给s1，由于String是不可变类型，不能够将原来地址中存放的内容改变成”def”，所以将创建新的”def”，并将它的地址赋值给s1，所以此时输出结果为false。</p><h2 id="和equals"><strong>==和equals</strong></h2><p>在java中等号<strong>==</strong>一般用于判断两者内存地址是否相同，而重载过的equals方法常用于判断内容是否相同，比如在String.java源码中，equals方法定义如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">anObject</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">anObject</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">anObject</span> <span class="k">instanceof</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">aString</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span><span class="n">anObject</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">coder</span><span class="o">()</span> <span class="o">==</span> <span class="n">aString</span><span class="o">.</span><span class="na">coder</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">isLatin1</span><span class="o">()</span> <span class="o">?</span> <span class="nc">StringLatin1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">aString</span><span class="o">.</span><span class="na">value</span><span class="o">)</span>
                              <span class="o">:</span> <span class="nc">StringUTF16</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">aString</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>首先判断内存地址是否相等，如果内存地址相等，说明两者指向同一对象，那么存储的内容也必然是相同的；如果内存地址不相等，再判断待比较的对象是否是String类的实例，如果是，再判断编码方式是否相同（单字节编码或双字节编码），在编码方式相同的情况下，分别调用不同编码方式下的比较函数，比较它们的value值（上面所提到的value数组）是否相等。</p><h2 id="字符串常量池"><strong>字符串常量池</strong></h2><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化：为字符串开辟一个字符串常量池，类似于缓存区；创建字符串常量时，首先检查字符串常量池是否存在该字符串，如果存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span>
</pre></table></code></div></div><p>首先创建一个字符串”abc”，由于常量池中当前没有任何字符串，所以创建该字符串”abc”并将其加入字符串常量池中，然后返回其引用（地址），接着创建s2，首先在线程池中检查，发现有”abc”，所以直接返回其引用（地址），所以输出结果为true；</p><p>在如下的例子中，稍微做了一些改变：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span>
</pre></table></code></div></div><p>这段代码使用构造函数来构造一个字符串”abc”，此时输出结果为false，表明两者指向的地址不同，如果按照上面的思路，在构造s2时，首先检查常量池，发现有”abc”，那么应该直接返回它的地址，并得到true的结果，但并不是这样的；对于用String( )构造的字符串，它们不属于常量，而是变量，不能在程序编译的时候就确定地址，它们有自己的内存地址空间；也就是说在JVM机制中，常量和变量享有不同区域的内存空间，两者是不会重叠的；</p><p>再看如下代码段：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">intern</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span>
</pre></table></code></div></div><p>此时输出结果为true，加了一行代码，结果就变的不同；intern( )是扩充常量池的一个方法；当一个String实例调用intern()方法时，Java查找常量池中是否有相同的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加此字符串并返回它的引用；</p><p>所以在本段代码中，对s2调用intern方法时，检查到常量池中有”abc”，所以返回它的引用，所以s1和s2指向的是同一个来自于常量池中的”abc”，所以两者地址相同，结果为true，而原先s2指向的变量类型的”abc”被丢弃；</p><p>为了总结上述内容，再看如下代码段：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"x"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"x"</span><span class="o">;</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">intern</span><span class="o">();</span>
<span class="n">s2</span> <span class="o">=</span> <span class="s">"xxxx"</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s3</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"s1 : "</span> <span class="o">+</span> <span class="n">s1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"s2 : "</span> <span class="o">+</span> <span class="n">s2</span><span class="o">);</span>
</pre></table></code></div></div><p>输出结果为：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">trues1</span> <span class="o">:</span> <span class="n">xs2</span> <span class="o">:</span> <span class="n">xxxx</span>
</pre></table></code></div></div><p>第1行，使用String构造函数创建字符串”x”，同时在常量池中增加”x”，此时s1指向的是变量类型的”x”，而不是常量池中的”x”；</p><p>第2行，将s1赋值给s2，此时s2指向变量类型的”x”；</p><p>第3行，创建”x”，返回的是常量池中的”x”的地址；</p><p>第4行，将s1指向常量池中的”x”；</p><p>第5行，改变s2为”xxxx”，并将其添加到常量池中；</p><p>第6行，得到结果为true，因为都指向常量池中对象；</p><p>第7行，结果为x；</p><p>第8行，由于是不可变类型，所以输出xxxx；</p><p>常量的编译优化</p><p>看如下的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span><span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">;</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span><span class="n">s1</span> <span class="o">=</span> <span class="s">"a"</span> <span class="o">+</span> <span class="s">"b"</span> <span class="o">+</span> <span class="s">"c"</span><span class="o">;</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span>
</pre></table></code></div></div><p>结果为：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">truetrue</span>
</pre></table></code></div></div><p>在IDE中查看.class文件，其实是查看它反编译后的代码，查看上述代码反编译后的代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span><span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">;</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s1</span><span class="o">);</span><span class="n">s1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span>
</pre></table></code></div></div><p>在s1的地方，本来写的是三个字符串相加，但经过反编译查看得到是最后的结果，也就是编译器做出了优化，在编译时就能确定”a” + “b” + “c”的结果为”abc”，所以不会分别将abc添加到常量池中，而是对它们的结果进行添加；进一步地，通过javap -c查看字节码，也未发现有abc单独出现的迹象：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>0: ldc           #2                  // String abc       2: astore_1       3: aload_1       4: astore_2       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;       8: aload_1       9: aload_2      10: if_acmpne     17      13: iconst_1      14: goto          18      17: iconst_0      18: invokevirtual #4                  // Method java/io/PrintStream.println:(Z)V      21: ldc           #2                  // String abc      23: astore_1
</pre></table></code></div></div><p>在21行和0行，都只出现了完整的abc；</p><h2 id="杂问题"><strong>杂问题</strong></h2><p>问如下代码创建了几个对象：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span>
</pre></table></code></div></div><p>答：两个，一个在堆内存中（变量内存位置），一个在常量池中；</p><p>如下代码结果：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"ab"</span><span class="o">;</span><span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"abc"</span><span class="o">;</span><span class="nc">String</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="s">"c"</span><span class="o">;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s3</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span>
</pre></table></code></div></div><p>答：false，常量和变量相加得到变量，所以s3指向的是变量的空间，s2指向的是常量池中地址，两者不可能相等；</p><p><strong>–end–</strong></p></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Java中的String - Littlemoon&url=https://littlemoon-zh.github.io/posts/Java-string/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Java中的String - Littlemoon&u=https://littlemoon-zh.github.io/posts/Java-string/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Java中的String - Littlemoon&url=https://littlemoon-zh.github.io/posts/Java-string/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Java-StringBuilder-And-StringBuffer/">StringBuilder and StringBuffer in Java</a><li><a href="/posts/remove-entry-from-linkedlist/">remove entry from linkedlist(using C)</a><li><a href="/posts/python-asyncio/">python异步io</a><li><a href="/posts/Markdown-syntax/">Text and Typography</a><li><a href="/posts/Java-string/">Java中的String</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/c/">C</a> <a class="post-tag" href="/tags/io/">io</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/%E5%BC%82%E6%AD%A5io/">异步io</a> <a class="post-tag" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Java-StringBuilder-And-StringBuffer/"><div class="card-body"> <span class="timeago small" > Aug 31 <i class="unloaded">2021-08-31T19:24:00-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>StringBuilder and StringBuffer in Java</h3><div class="text-muted small"><p> StringBuilder(since 1.5) (Mutable): A mutable sequence of characters. (No synchronization): This class provides an API compatible with StringBuffer, but with no guarantee of synchronization. This...</p></div></div></a></div><div class="card"> <a href="/posts/remove-entry-from-linkedlist/"><div class="card-body"> <span class="timeago small" > Jun 15 <i class="unloaded">2021-06-15T14:00:00-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>remove entry from linkedlist(using C)</h3><div class="text-muted small"><p> 链表节点定义如下： 1 2 3 4 typedef struct node { int val; struct node* next; } Node; 一般而言，我们通过给定指针，删除链表中指定元素的算法是这样的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void remove_list_entry_2(Node* entry) { No...</p></div></div></a></div><div class="card"> <a href="/posts/python-asyncio/"><div class="card-body"> <span class="timeago small" > May 30 <i class="unloaded">2021-05-30T10:00:00-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>python异步io</h3><div class="text-muted small"><p> 异步io example 让人对某件事情感兴趣的最好方法，就是让他看到这个事情的巨大效益，所以先来几个example。 我们在这里用三种方式做同样的事情：请求一个url若干次，获取它的响应，打印出来，并且统计执行时间， 请求的url是https://httpbin.org/uuid，每次请求这个接口，就会返回一个uuid，不过这里返回什么对我们不重要，重要的是有一个请求，有一个响应；...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Markdown-syntax/" class="btn btn-outline-primary" prompt="Older"><p>Text and Typography</p></a> <a href="/posts/quick-sort/" class="btn btn-outline-primary" prompt="Newer"><p>快速排序的一些注意点</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/username">littlemoon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">All rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/c/">C</a> <a class="post-tag" href="/tags/io/">io</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/%E5%BC%82%E6%AD%A5io/">异步io</a> <a class="post-tag" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://littlemoon-zh.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
