

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://littlemoon-zh.github.io/</id>
  <title>Littlemoon</title>
  <subtitle>littlemoon's blog</subtitle>
  <updated>2021-06-08T00:04:40+08:00</updated>
  <author>
    <name>littlemoon</name>
    <uri>https://littlemoon-zh.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://littlemoon-zh.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en-US"
    href="https://littlemoon-zh.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 littlemoon </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>python异步io</title>
    <link href="https://littlemoon-zh.github.io/posts/python-asyncio/" rel="alternate" type="text/html" title="python异步io" />
    <published>2021-05-30T22:00:00+08:00</published>
  
    <updated>2021-05-30T22:00:00+08:00</updated>
  
    <id>https://littlemoon-zh.github.io/posts/python-asyncio/</id>
    <content src="https://littlemoon-zh.github.io/posts/python-asyncio/" />
    <author>
      <name>littlemoon</name>
    </author>

  
    
  

  
    <summary>
      





      异步io

example

让人对某件事情感兴趣的最好方法，就是让他看到这个事情的巨大效益，所以先来几个example。

我们在这里用三种方式做同样的事情：请求一个url若干次，获取它的响应，打印出来，并且统计执行时间，

请求的url是https://httpbin.org/uuid，每次请求这个接口，就会返回一个uuid，不过这里返回什么对我们不重要，重要的是有一个请求，有一个响应；

三种实现方式是：


  单线程同步
  多线程同步
  异步io


统计时间
逻辑就是分别记录任务执行前后的时间，然后打印差值得到任务运行时间；这里我们使用一种原理相同，但是看起来高级一点的方式，使用functools中的wraps做一个统计执行之间的装饰器：
def time_cost(fn):
    if asyncio.iscoroutinefunction(fn):
      ...
    </summary>
  

  </entry>

  
  <entry>
    <title>快速排序的一些注意点</title>
    <link href="https://littlemoon-zh.github.io/posts/quick-sort/" rel="alternate" type="text/html" title="快速排序的一些注意点" />
    <published>2019-12-20T22:00:00+08:00</published>
  
    <updated>2019-12-20T22:00:00+08:00</updated>
  
    <id>https://littlemoon-zh.github.io/posts/quick-sort/</id>
    <content src="https://littlemoon-zh.github.io/posts/quick-sort/" />
    <author>
      <name>littlemoon</name>
    </author>

  
    
  

  
    <summary>
      





      本文不是快速排序教程，而是记录其中值得关注的细节。

快速排序的思想很简单，接触过的人应该很容易记住，就是按一定的策略选一个pivot，然后按照一定的策略把pivot移到合适的位置，使得前面的都比它小，后面的都比它大，一样的两边都可以放，最后分别处理前后两个部分。伪代码如下：

quicksort a[], lo, hi:
	if lo &amp;gt;= hi, return;
	p = partition(a, lo, hi);
	quicksort(a, lo, p - 1);
	quicksort(a, p + 1, hi);


所以关键就是这个partition函数的内容，一旦处理不好，就退化成O(N^2)的时间复杂度；最好的情况是O(NlogN)，因为每一轮都要遍历所有元素N，最少有LogN轮，也就是每次都对半划分的时候会达到最小。

划分一般有两种策略，一个是单指针法，一个是...
    </summary>
  

  </entry>

  
  <entry>
    <title>Java中的String</title>
    <link href="https://littlemoon-zh.github.io/posts/Java-string/" rel="alternate" type="text/html" title="Java中的String" />
    <published>2019-04-08T19:50:00+08:00</published>
  
    <updated>2019-04-08T19:50:00+08:00</updated>
  
    <id>https://littlemoon-zh.github.io/posts/Java-string/</id>
    <content src="https://littlemoon-zh.github.io/posts/Java-string/" />
    <author>
      <name>littlemoon</name>
    </author>

  
    
  

  
    <summary>
      





      不可变类型

String是不可变类型（immutable），String.java源码中声明如下：

private final byte[] value;


String通过字节数组来实现，且被声明为private final byte类型，表明对外的不可访问性（private），以及不可改变性（final）；

如果试图对其改变，会生成新的对象：

String s1 = "abc";
String s2 = s1;
System.out.println(s1 == s2);
s1 = "def";
System.out.println(s1 == s2);


输出结果为：

true
false


原本s1和s2指向的是同一内存空间地址，所以先输出true，接着将”def”赋值给s1，由于String是不可变类型，不能够将原来地址中存放的内容改变成”def”，所以将创建...
    </summary>
  

  </entry>

  
  <entry>
    <title>Text and Typography</title>
    <link href="https://littlemoon-zh.github.io/posts/Markdown-syntax/" rel="alternate" type="text/html" title="Text and Typography" />
    <published>2000-06-05T13:22:54+08:00</published>
  
    <updated>2000-06-05T13:22:54+08:00</updated>
  
    <id>https://littlemoon-zh.github.io/posts/Markdown-syntax/</id>
    <content src="https://littlemoon-zh.github.io/posts/Markdown-syntax/" />
    <author>
      <name>Cotes Chung</name>
    </author>

  
    
  

  
    <summary>
      





      This post is to show Markdown syntax rendering on Chirpy, you can also use it as an example of writing. Now, let’s start looking at text and typography.

Titles

H1 - heading


H4 - heading



Paragraph

I wandered lonely as a cloud

That floats on high o’er vales and hills,

When all at once I saw a crowd,

A host, of golden daffodils;

Beside the lake, beneath the trees,

Fluttering and danci...
    </summary>
  

  </entry>

</feed>


