[ { "title": "StringBuilder and StringBuffer in Java", "url": "/posts/Java-StringBuilder-And-StringBuffer/", "categories": "", "tags": "Java", "date": "2021-08-31 19:24:00 -0400", "snippet": "StringBuilder(since 1.5)(Mutable): A mutable sequence of characters.(No synchronization): This class provides an API compatible with StringBuffer, but with no guarantee of synchronization. This class is designed for use as a drop-in replacement for StringBuffer in places where the string buffer w..." }, { "title": "remove entry from linkedlist(using C)", "url": "/posts/remove-entry-from-linkedlist/", "categories": "", "tags": "算法, C", "date": "2021-06-15 14:00:00 -0400", "snippet": "链表节点定义如下：typedef struct node { int val; struct node* next;} Node;一般而言，我们通过给定指针，删除链表中指定元素的算法是这样的：void remove_list_entry_2(Node* entry) { Node *prev, *cur = head; while (cur != entry) { prev = cur; cur = cur-&amp;gt;next; } if (prev) { prev-&amp;gt;next = entr..." }, { "title": "python异步io", "url": "/posts/python-asyncio/", "categories": "", "tags": "Python, io, 异步io", "date": "2021-05-30 10:00:00 -0400", "snippet": "异步ioexample让人对某件事情感兴趣的最好方法，就是让他看到这个事情的巨大效益，所以先来几个example。我们在这里用三种方式做同样的事情：请求一个url若干次，获取它的响应，打印出来，并且统计执行时间，请求的url是https://httpbin.org/uuid，每次请求这个接口，就会返回一个uuid，不过这里返回什么对我们不重要，重要的是有一个请求，有一个响应；三种实现方式是： 单线程同步 多线程同步 异步io统计时间逻辑就是分别记录任务执行前后的时间，然后打印差值得到任务运行时间；这里我们使用一种原理相同，但是看起来高级一点的方式，使用functools中的wrap..." }, { "title": "快速排序的一些注意点", "url": "/posts/quick-sort/", "categories": "", "tags": "算法, 排序算法", "date": "2019-12-20 09:00:00 -0500", "snippet": "本文不是快速排序教程，而是记录其中值得关注的细节。快速排序的思想很简单，接触过的人应该很容易记住，就是按一定的策略选一个pivot，然后按照一定的策略把pivot移到合适的位置，使得前面的都比它小，后面的都比它大，一样的两边都可以放，最后分别处理前后两个部分。伪代码如下：quicksort a[], lo, hi: if lo &amp;gt;= hi, return; p = partition(a, lo, hi); quicksort(a, lo, p - 1); quicksort(a, p + 1, hi);所以关键就是这个partition函数的内容，一旦处理不好，就退化成O..." }, { "title": "Java中的String", "url": "/posts/Java-string/", "categories": "", "tags": "Java", "date": "2019-04-08 07:50:00 -0400", "snippet": "不可变类型String是不可变类型（immutable），String.java源码中声明如下：private final byte[] value;String通过字节数组来实现，且被声明为private final byte类型，表明对外的不可访问性（private），以及不可改变性（final）；如果试图对其改变，会生成新的对象：String s1 = &quot;abc&quot;;String s2 = s1;System.out.println(s1 == s2);s1 = &quot;def&quot;;System.out.println(s1 == s2);输出结果为：..." }, { "title": "Text and Typography", "url": "/posts/Markdown-syntax/", "categories": "", "tags": "", "date": "2000-06-05 01:22:54 -0400", "snippet": "This post is to show Markdown syntax rendering on Chirpy, you can also use it as an example of writing. Now, let’s start looking at text and typography.TitlesH1 - headingH4 - headingParagraphI wandered lonely as a cloudThat floats on high o’er vales and hills,When all at once I saw a crowd,A host..." } ]
